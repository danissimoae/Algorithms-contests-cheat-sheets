### Ex 1 - ?
```python
count,funds = map(int, input().split())
price = list(map(int,input().split()))
def ex1(count,funds,price):
    price.sort()
    ans = 0
    if count > 0:
        for i in reversed(range(count)):
            if price[i] <= funds:
                ans = price[i]
                break
    return ans
print(ex1(count,funds,price))
```


### Ex 2 - ?
```python
string = input()
def sheriff(str):   
    dictionary = {'s':0,'h':0,'e':0,'r':0,'i':0,'f':0}
    ans = 0
    for char in string:
        if char in dictionary:
            dictionary[char] += 1
        
    while dictionary['s'] >=1 and dictionary['h'] >= 1 and dictionary['e'] >= 1 and dictionary['r'] >= 1 and dictionary['i'] >= 1 and dictionary['f'] >= 2:
        ans +=1
        for i in 'sheriff':
            dictionary[i] -= 1
    return ans
print(sheriff(string))
```


### Ex 3
### Перед ковбоем выложены ﻿n карт со значениями ﻿a1,a2,…,an. Он хочет получить выигрышную последовательность карт со значениями ﻿b1,b2,…,bn.
Ковбой может выбрать непрерывный отрезок карт в своей последовательности ﻿[l,r] (﻿1≤l≤r≤n﻿) и упорядочить карты в этом отрезке по неубыванию. Например, если перед Ковбой лежат карты ﻿{3,3,2,5,1,5}{3,3,2,5,1,5}﻿, он может выбрать отрезок ﻿[2,5][2,5]﻿ и получить последовательность ﻿{3,1,2,3,5,5}{3,1,2,3,5,5}﻿.
Получится ли у Ковбоя получить выигрышную последовательность с помощью применения вышеописанной операции ровно один раз? 
Формат входных данных
В первой строке дано целое число ﻿n - количество карт в последовательности.
Во второй строке даны ﻿n﻿ целых чисел ﻿a1,a2,…,an﻿) — последовательность Ковбоя.
В третьей строке даны ﻿n﻿ целых чисел ﻿b1,b2,…,bn — выигрышная последовательность.
Формат выходных данных
Выведите «﻿YES﻿» (без кавычек), если Ваня может получить выигрышную последовательность, иначе выведите «﻿NO﻿»
```python
n = int(input())
cards = list(map(int,input().split()))
win_cards = list(map(int,input().split()))

def count_cards(n, cards, wcards):
    i = 0
    while i < n and cards[i] == wcards[i]:
        i += 1
    
    if i == n:
        return 'YES'
    else:
        j = n - 1
        while j >= 0 and cards[j] == wcards[j]:
            j -= 1
    
    if sorted(cards[i:j+1]) == wcards[i:j+1]:
        return 'YES'
    else:
        return 'NO'
print(count_cards(n, cards, win_cards))
```


```python
### Ex 4
### В первой строке даны целые числа ﻿n,m﻿) — необходимая Ване сумма и количество номиналов купюр.
Во второй строке вводятся ﻿mm﻿ попарно различных целых чисел ﻿a1,a2,…,am — существующие номиналы купюр. 
Формат выходных данных
Если Ваня сможет украсть ровно ﻿n﻿ долларов, выведите число ﻿k — количество украденных купюр. Затем выведите ﻿k﻿ целых чисел — номиналы купюр. Если решений несколько, вы можете вывести любое.
В противном случае выведите ﻿−1.

n,m = map(int, input().split())
nominals = list(map(int,input().split()))

def money(n,m,nominals):
    nominals.sort()
    cnt = [0] * m
    sum_ans = 0
    ans = []

    for i in range(m-1,-1,-1):
        while n >= nominals[i] and cnt[i] <= (n // nominals[i]):
            cnt[i] += 1
            n -= nominals[i]
    if n == 0:
        sum_ans = sum(cnt)
        for i in range(m):
            for j in range(cnt[i]):
                ans.append(nominals[i])
    else:
        return -1
    
    s = " ".join(str(x) for x in ans)
    return f"{sum_ans}\n{s}"
    
print(money(n,m,nominals))
```



###Ex 5 -  Древний индейский дух Чогэн пробудился и отправился карать бледнолицых. Ничто не способно его остановить, так что ковбой Джо выступает в роли наблюдателя в этой задаче.

На Диком западе ﻿nn﻿ городов и ﻿mm﻿ двусторонних дорог между ними. Штатом называется такое множества городов, для которого верно:

    Из любого города этого множества можно добраться по дорогам до любого другого города из этого множества;
    Из любого города этого множества нельзя добраться по дорогам до любого города не из этого множества.

Из любого города можно добраться по дорогам до самого себя, используя ﻿00﻿ дорог.
Дух Чогэн выбирает целое число ﻿xx﻿ и уничтожает все дороги длиной не более ﻿xx﻿. Несложно заметить, что Дикий запад однозначно разбивается на штаты. Дух Чогэн хочет уничтожить как можно больше дорог, но количество штатов должно остаться неизменным. Помогите духу выбрать число ﻿xx﻿.

Формат входных данных
В первой строке даны целые числа ﻿n,mn,m﻿ (﻿2≤n≤2⋅105,1≤m≤2⋅1052≤n≤2⋅105,1≤m≤2⋅105﻿) — количество городов и дорог.
В следующих ﻿mm﻿ строках даны целые числа ﻿v,u,wv,u,w﻿ (﻿1≤v,u≤n,1≤w≤1091≤v,u≤n,1≤w≤109﻿) — номера городов, соединенных дорогой и её длина.
Между какими-то городами могут быть проведены несколько дорог, также могут быть дороги из города в себя же.

Гарантируется, что изначальное количество штатов строго меньше ﻿nn﻿.

Формат выходных данных

В единственной строке выведите целое число ﻿xx

```python
n,m = map(int,input().split())
graph = [[] for _ in range(n)]
for i in range(m):
    v, u, w = map(int,input().split())
    graph[v-1].append((u-1, w))
    graph[u-1].append((v-1, w))

def dfs(v, visited, x):
    visited[v] = True
    for u, w in graph[v]:
        if not visited[u] and w <= x:
            dfs(u, visited, x)

def cnt_states(x):
    visited = [False] * n
    cnt = 0
    for i in range(n):
        if not visited[i]:
            dfs(i, visited, x)
            cnt += 1
    return cnt

l, r = 0, 10**9
while l < r:
    mid = (l + r) // 2
    if cnt_states(mid) < n:
        r = mid
    else:
        l = mid + 1
    
print(l)
```

### Ex 6 - Однажды ковбой Джо забрёл в жуткую заброшенную шахту, в которой обитают ﻿nn﻿ духов с номерами ﻿1,2,…,n1,2,…,n﻿. Сейчас каждый дух состоит в банде из самого себя. В один момент времени каждый дух может находиться ровно в одной банде. По одиночке духи слабы, поэтому вскоре банды начнут объединяться. Когда две банды объединяются, создаётся новая банда, в которую попадают все духи из объединяющихся банд, в то время как старые банды распадаются.

Ковбоя Джо оглушил душераздирающий крик, который сообщил ему о необходимости ответить на ﻿mm﻿ вопросов. Если ковбой Джо откажется отвечать на вопросы крика или ошибётся, то навечно сгинет в заброшенной шахте.

Дух задаст ﻿mm﻿ вопросов, каждый из которых относится к одному из трёх типов.

    Духи ﻿xx﻿ и ﻿yy﻿ объединяются в банду. Если они уже находятся в одной банде, ничего не происходит.
    Крик спрашивает ковбоя Джо, находятся ли духи ﻿xx﻿ и ﻿yy﻿ в одной банде.
    Крик спрашивает ковбоя Джо, в скольких бандах побывал дух ﻿xx﻿.

Например, если ﻿n=7n=7﻿, а банды выглядели так: ﻿[1,3],[4,6,2],[5],[7][1,3],[4,6,2],[5],[7]﻿, и крик сообщил об объединении банд с духами ﻿11﻿ и ﻿55﻿, банды будут выглядеть так: ﻿[1,5,3],[4,6,2],[7][1,5,3],[4,6,2],[7]﻿. Духи ﻿1,3,51,3,5﻿ побывали в двух бандах, духи ﻿2,4,6,72,4,6,7﻿ в одной.

Формат входных данных

В первой строке даны целые числа ﻿n,mn,m﻿ (﻿1≤n,m≤2⋅1051≤n,m≤2⋅105﻿) — количество духов и вопросов крика.

Следующие ﻿mm﻿ строк содержат описание вопросов:

    ﻿11﻿ ﻿xx﻿ ﻿yy﻿ (﻿1≤x,y≤n1≤x,y≤n﻿)
    ﻿22﻿ ﻿xx﻿ ﻿yy﻿ (﻿1≤x,y≤n1≤x,y≤n﻿)
    ﻿33﻿ ﻿xx﻿ (﻿1≤x≤n1≤x≤n﻿)

Формат выходных данных

Для каждого вопроса второго типа выведите <<﻿YESYES﻿>> или <<﻿NONO﻿>> (без кавычек).

Для каждого вопроса третьего типа выведите целое число — ответ на вопрос.
```pytHon
class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        
        if x_root == y_root:
            return
        
        if self.rank[x_root] < self.rank[y_root]:
            self.parent[x_root] = y_root
        elif self.rank[x_root] > self.rank[y_root]:
            self.parent[y_root] = x_root
        else:
            self.parent[y_root] = x_root
            self.rank[x_root] += 1


n, m = map(int, input().split())

ds = DisjointSet(n)
for _ in range(m):
    query = input().split()
    
    if query[0] == '1':
        x, y = int(query[1]) - 1, int(query[2]) - 1
        ds.union(x, y)
    elif query[0] == '2':
        x, y = int(query[1]) - 1, int(query[2]) - 1
        if ds.find(x) == ds.find(y):
            print("YES")
        else:
            print("NO")
    elif query[0] == '3':
        x = int(query[1]) - 1
        count = len(set(ds.find(i) for i in range(n) if ds.find(i) == ds.find(x)))
        print(count)
```
