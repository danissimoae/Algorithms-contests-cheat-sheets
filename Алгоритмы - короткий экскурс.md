
Задача сортировки всегда заключается в том, чтобы расставить элементы массива в определенном порядке, зачастую по неубыванию.

Для оценки сложности выполнения алгоритмов придумали О-нотацию (О-большое) - асимптотическое время работы вместо точного (асимптотика).

## О-большое

О-большое (big-O) - это **математическая функция, используемая в информатике для описания сложности алгоритма, или, более конкретно, времени выполнения, требуемого алгоритмом**.

О-большое удобно использовать, так как:
- На разных компьютерах скорость выполнения алгоритма будет отличаться
- Не всегда заранее доступны данные, которые будет использовать алгоритм
- Хочется предсказать, какой алгоритм будет работать ресурсо-эффективнее.

Примеры использования $О-большого:$
- сортировка пузырьком работает за $O(n^2)$
- сортировка выбором работает за $O(n^2)$
- сортировка вставками работает за $O(n^2)$
- сортировка подсчетом работает за $O(n+m)$



# Алгоритмы сортировки

### Сортировка пузырьком (bubble sort)

```python
def bubble_sort(arr):
    for i in range(len(arr)-1):
        for j in range(len(arr)-i-1):
            if arr[j]>arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr
```

Среднее время | $O(n^2)$
--- | --- 
Лучший кейс | $O(n)$
Худший кейс | $O(n^2)$

Название пошло от того, что каждую итерацию алгоритма максимальный элемент "всплывает" как пузырек к концу массива.

Асимптотика. Так как у нас два вложенных цикла, каждый из которых делает не более $O(n)$ итераций, внутри которых за $O(1)$ происходит сравнение, суммарное время работы будет не более $O(n^2)$.




### Сортировка выбором (selection sort)

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n-1):
        min_idx = i
        for j in range(i+1,n):
            if (arr[j]<arr[min_idx]):
                min_idx = j
        arr[i],arr[min_idx] = arr[min_idx],arr[i]
    return arr
```

Среднее время | $O(n^2)$
--- | --- 
Лучший кейс | $O(n^2)$
Худший кейс | $O(n^2)$ 

Шаги алгоритма:
1. Находим номер минимального значения в текущем списке.
2. Производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции).
3. Теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы.




### Сортировка вставкой (insertion sort)

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n-1):
        min_idx = i
        for j in range(i+1,n):
            if (arr[j]<arr[min_idx]):
                min_idx = j
        arr[i],arr[min_idx] = arr[min_idx],arr[i]
    return arr
```

Среднее время | $O(n^2)$
--- | --- 
Лучший кейс | $O(n)$
Худший кейс | $O(n^2)$ 




### Пирамидальная сортировка / сортировка кучей (heapsort)

```python
def heapify(arr,n,i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[i] < arr[l]:
        largest = i

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i]
        heapify(arr,n,largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n//2,-1,-1):
        heapify(arr,n,i)

    for i in range(n-1,0,-1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr,i,0)
```

Среднее время | $O(nlog n)$
--- | --- 
Лучший кейс | $O(nlogn)$
Худший кейс | $O(nlogn)$ 




### Сортировка подсчетом

```python
def count_sort(arr):
    t = [0]*101
    for i in arr:
        t[i]+=1
    arr = []
    for i in range(101):
        arr+=[i]*t[i]
    return arr
```


Среднее время | $O(m + n)$
--- | --- 
Лучший кейс | $O(m+n)$
Худший кейс | $O(m+n)$ 

Создадим массив cc размера 100100 и заполним его, один раз пройдясь по исходному массиву. За итерацию, переходя на следующий элемент увеличиваем количества этого элемента в массиве

Асимптотика. Время работы такого алгоритма составляет $O(m+n)$, где $m$ — число возможных значений, $n$ — число элементов в массиве. Если количество возможных различных элементов в множестве относительно невелико, то сортировка подсчетом является одним из самых оптимальных решений.




### Цифровая сортировка (radix)

```python
def radix_sort(arr):
    
    # находим размер самого длинного числа
    max_digits = max([len(str(x)) for x in arr])

    # основание системы счисления
    base = 10

    # создаём промежуточный пустой массив из 10 элементов
    bins = [[] for _ in range(base)]

    # перебираем все разряды, начиная с нулевого
    for i in range(0, max_digits):
        # для удобства выводим текущий номер разряда, с которым будем работать
        print('✅ Номер разряда → ' + str(i))
        # перебираем все элементы в массиве
        for x in arr:
            # получаем цифру, стоящую на текущем разряде в каждом числе массива
            digit = (x // base ** i) % base
            # отправляем число в промежуточный массив в ячейку, которая совпадает со значением этой цифры 
            bins[digit].append(x)
        # собираем в исходный массив все ненулевые значения из промежуточного массива
        arr = [x for queue in bins for x in queue]
        # текущее состояние массива
        print(arr)
        # текущее состояние промежуточного массива
        print(bins)

        # очищаем промежуточный массив
        bins = [[] for _ in range(base)]

    # возвращаем отсортированный массив
    return arr
```

Цифровая сортировка — это способ применить идею сортировки подсчетом на большие ключи. Алгоритм поразрядной сортировки гениален в том, что сортирует не числа целиком, а значения разрядов. Получается, что он как бы разбирается с числами на уровне единиц, десятков, сотен и т. д. и только потом он делает общую сортировку. Это позволяет ему не бегать по всем сравниваемым числам и не делать миллион сравнений. Отсюда и экономия времени.


Среднее время | $O(d*(n+b))$
--- | --- 
Лучший кейс | $O(d*(n+b))$
Худший кейс | $O(d*(n+b))$ 



`Краткий cheat-sheet от` [Dariusss](https://github.com/danissimoae)
[Github](https://github.com/danissimoae)

`Ресурсы - 
https://ru.algorithmica.org/
https://sortvisualizer.com/